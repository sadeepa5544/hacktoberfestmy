// Type definitions for non-npm package estree 1.0
// Project: https://github.com/estree/estree
// Definitions by: RReverser <https://github.com/RReverser>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

// This definition file follows a somewhat unusual format. ESTree allows
// runtime type checks based on the `type` parameter. In order to explain this
// to typescript we want to use discriminated union types:
// https://github.com/Microsoft/TypeScript/pull/9163
//
// For ESTree this is a bit tricky because the high level interfaces like
// Node or Function are pulling double duty. We want to pass common fields down
// to the interfaces that extend them (like Identifier or
// ArrowFunctionExpression), but you can't extend a type union or enforce
// common fields on them. So we've split the high level interfaces into two
// types, a base type which passes down inherited fields, and a type union of
// all types which extend the base type. Only the type union is exported, and
// the union is how other types refer to the collection of inheriting types.
//
// This makes the definitions file here somewhat more difficult to maintain,
// but it has the notable advantage of making ESTree much easier to use as
// an end user.

export interface BaseNodeWithoutComments {
    // Every leaf interface that extends BaseNode must specify a type property.
    // The type property should be a string literal. For example, Identifier
    // has: `type: "Identifier"`
    type: string;
    loc?: SourceLocation | null | undefined;
    range?: [number, number] | undefined;
}

export interface BaseNode extends BaseNodeWithoutComments {
    leadingComments?: Comment[] | undefined;
    trailingComments?: Comment[] | undefined;
}

export interface NodeMap {
    AssignmentProperty: AssignmentProperty;
    CatchClause: CatchClause;
    Class: Class;
    ClassBody: ClassBody;
    Expression: Expression;
    Function: Function;
    Identifier: Identifier;
    Literal: Literal;
    MethodDefinition: MethodDefinition;
    ModuleDeclaration: ModuleDeclaration;
    ModuleSpecifier: ModuleSpecifier;
    Pattern: Pattern;
    PrivateIdentifier: PrivateIdentifier;
    Program: Program;
    Property: Property;
    PropertyDefinition: PropertyDefinition;
    SpreadElement: SpreadElement;
    Statement: Statement;
    Super: Super;
    SwitchCase: SwitchCase;
    TemplateElement: TemplateElement;
    VariableDeclarator: VariableDeclarator;
}

export type Node = NodeMap[keyof NodeMap];

export interface Comment extends BaseNodeWithoutComments {
<<<<<<< Updated upstream
    type: "Line" | "Block";
=======
    type: 'Line' | 'Block';
>>>>>>> Stashed changes
    value: string;
}

export interface SourceLocation {
    source?: string | null | undefined;
    start: Position;
    end: Position;
}

export interface Position {
    /** >= 1 */
    line: number;
    /** >= 0 */
    column: number;
}

export interface Program extends BaseNode {
<<<<<<< Updated upstream
    type: "Program";
    sourceType: "script" | "module";
=======
    type: 'Program';
    sourceType: 'script' | 'module';
>>>>>>> Stashed changes
    body: Array<Directive | Statement | ModuleDeclaration>;
    comments?: Comment[] | undefined;
}

export interface Directive extends BaseNode {
<<<<<<< Updated upstream
    type: "ExpressionStatement";
=======
    type: 'ExpressionStatement';
>>>>>>> Stashed changes
    expression: Literal;
    directive: string;
}

export interface BaseFunction extends BaseNode {
    params: Pattern[];
    generator?: boolean | undefined;
    async?: boolean | undefined;
    // The body is either BlockStatement or Expression because arrow functions
    // can have a body that's either. FunctionDeclarations and
    // FunctionExpressions have only BlockStatement bodies.
    body: BlockStatement | Expression;
}

export type Function = FunctionDeclaration | FunctionExpression | ArrowFunctionExpression;

export type Statement =
    | ExpressionStatement
    | BlockStatement
    | StaticBlock
    | EmptyStatement
    | DebuggerStatement
    | WithStatement
    | ReturnStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | IfStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | ForInStatement
    | ForOfStatement
    | Declaration;

export interface BaseStatement extends BaseNode {}

export interface EmptyStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "EmptyStatement";
}

export interface BlockStatement extends BaseStatement {
    type: "BlockStatement";
=======
    type: 'EmptyStatement';
}

export interface BlockStatement extends BaseStatement {
    type: 'BlockStatement';
>>>>>>> Stashed changes
    body: Statement[];
    innerComments?: Comment[] | undefined;
}

<<<<<<< Updated upstream
export interface StaticBlock extends Omit<BlockStatement, "type"> {
    type: "StaticBlock";
}

export interface ExpressionStatement extends BaseStatement {
    type: "ExpressionStatement";
=======
export interface StaticBlock extends Omit<BlockStatement, 'type'> {
    type: 'StaticBlock';
}

export interface ExpressionStatement extends BaseStatement {
    type: 'ExpressionStatement';
>>>>>>> Stashed changes
    expression: Expression;
}

export interface IfStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "IfStatement";
=======
    type: 'IfStatement';
>>>>>>> Stashed changes
    test: Expression;
    consequent: Statement;
    alternate?: Statement | null | undefined;
}

export interface LabeledStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "LabeledStatement";
=======
    type: 'LabeledStatement';
>>>>>>> Stashed changes
    label: Identifier;
    body: Statement;
}

export interface BreakStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "BreakStatement";
=======
    type: 'BreakStatement';
>>>>>>> Stashed changes
    label?: Identifier | null | undefined;
}

export interface ContinueStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "ContinueStatement";
=======
    type: 'ContinueStatement';
>>>>>>> Stashed changes
    label?: Identifier | null | undefined;
}

export interface WithStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "WithStatement";
=======
    type: 'WithStatement';
>>>>>>> Stashed changes
    object: Expression;
    body: Statement;
}

export interface SwitchStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "SwitchStatement";
=======
    type: 'SwitchStatement';
>>>>>>> Stashed changes
    discriminant: Expression;
    cases: SwitchCase[];
}

export interface ReturnStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "ReturnStatement";
=======
    type: 'ReturnStatement';
>>>>>>> Stashed changes
    argument?: Expression | null | undefined;
}

export interface ThrowStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "ThrowStatement";
=======
    type: 'ThrowStatement';
>>>>>>> Stashed changes
    argument: Expression;
}

export interface TryStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "TryStatement";
=======
    type: 'TryStatement';
>>>>>>> Stashed changes
    block: BlockStatement;
    handler?: CatchClause | null | undefined;
    finalizer?: BlockStatement | null | undefined;
}

export interface WhileStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "WhileStatement";
=======
    type: 'WhileStatement';
>>>>>>> Stashed changes
    test: Expression;
    body: Statement;
}

export interface DoWhileStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "DoWhileStatement";
=======
    type: 'DoWhileStatement';
>>>>>>> Stashed changes
    body: Statement;
    test: Expression;
}

export interface ForStatement extends BaseStatement {
<<<<<<< Updated upstream
    type: "ForStatement";
=======
    type: 'ForStatement';
>>>>>>> Stashed changes
    init?: VariableDeclaration | Expression | null | undefined;
    test?: Expression | null | undefined;
    update?: Expression | null | undefined;
    body: Statement;
}

export interface BaseForXStatement extends BaseStatement {
    left: VariableDeclaration | Pattern;
    right: Expression;
    body: Statement;
}

export interface ForInStatement extends BaseForXStatement {
<<<<<<< Updated upstream
    type: "ForInStatement";
}

export interface DebuggerStatement extends BaseStatement {
    type: "DebuggerStatement";
=======
    type: 'ForInStatement';
}

export interface DebuggerStatement extends BaseStatement {
    type: 'DebuggerStatement';
>>>>>>> Stashed changes
}

export type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration;

export interface BaseDeclaration extends BaseStatement {}

export interface FunctionDeclaration extends BaseFunction, BaseDeclaration {
<<<<<<< Updated upstream
    type: "FunctionDeclaration";
=======
    type: 'FunctionDeclaration';
>>>>>>> Stashed changes
    /** It is null when a function declaration is a part of the `export default function` statement */
    id: Identifier | null;
    body: BlockStatement;
}

export interface VariableDeclaration extends BaseDeclaration {
<<<<<<< Updated upstream
    type: "VariableDeclaration";
    declarations: VariableDeclarator[];
    kind: "var" | "let" | "const";
}

export interface VariableDeclarator extends BaseNode {
    type: "VariableDeclarator";
=======
    type: 'VariableDeclaration';
    declarations: VariableDeclarator[];
    kind: 'var' | 'let' | 'const';
}

export interface VariableDeclarator extends BaseNode {
    type: 'VariableDeclarator';
>>>>>>> Stashed changes
    id: Pattern;
    init?: Expression | null | undefined;
}

export interface ExpressionMap {
    ArrayExpression: ArrayExpression;
    ArrowFunctionExpression: ArrowFunctionExpression;
    AssignmentExpression: AssignmentExpression;
    AwaitExpression: AwaitExpression;
    BinaryExpression: BinaryExpression;
    CallExpression: CallExpression;
    ChainExpression: ChainExpression;
    ClassExpression: ClassExpression;
    ConditionalExpression: ConditionalExpression;
    FunctionExpression: FunctionExpression;
    Identifier: Identifier;
    ImportExpression: ImportExpression;
    Literal: Literal;
    LogicalExpression: LogicalExpression;
    MemberExpression: MemberExpression;
    MetaProperty: MetaProperty;
    NewExpression: NewExpression;
    ObjectExpression: ObjectExpression;
    SequenceExpression: SequenceExpression;
    TaggedTemplateExpression: TaggedTemplateExpression;
    TemplateLiteral: TemplateLiteral;
    ThisExpression: ThisExpression;
    UnaryExpression: UnaryExpression;
    UpdateExpression: UpdateExpression;
    YieldExpression: YieldExpression;
}

export type Expression = ExpressionMap[keyof ExpressionMap];

export interface BaseExpression extends BaseNode {}

export type ChainElement = SimpleCallExpression | MemberExpression;

export interface ChainExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "ChainExpression";
=======
    type: 'ChainExpression';
>>>>>>> Stashed changes
    expression: ChainElement;
}

export interface ThisExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "ThisExpression";
}

export interface ArrayExpression extends BaseExpression {
    type: "ArrayExpression";
=======
    type: 'ThisExpression';
}

export interface ArrayExpression extends BaseExpression {
    type: 'ArrayExpression';
>>>>>>> Stashed changes
    elements: Array<Expression | SpreadElement | null>;
}

export interface ObjectExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "ObjectExpression";
=======
    type: 'ObjectExpression';
>>>>>>> Stashed changes
    properties: Array<Property | SpreadElement>;
}

export interface PrivateIdentifier extends BaseNode {
<<<<<<< Updated upstream
    type: "PrivateIdentifier";
=======
    type: 'PrivateIdentifier';
>>>>>>> Stashed changes
    name: string;
}

export interface Property extends BaseNode {
<<<<<<< Updated upstream
    type: "Property";
    key: Expression | PrivateIdentifier;
    value: Expression | Pattern; // Could be an AssignmentProperty
    kind: "init" | "get" | "set";
=======
    type: 'Property';
    key: Expression | PrivateIdentifier;
    value: Expression | Pattern; // Could be an AssignmentProperty
    kind: 'init' | 'get' | 'set';
>>>>>>> Stashed changes
    method: boolean;
    shorthand: boolean;
    computed: boolean;
}

export interface PropertyDefinition extends BaseNode {
<<<<<<< Updated upstream
    type: "PropertyDefinition";
=======
    type: 'PropertyDefinition';
>>>>>>> Stashed changes
    key: Expression | PrivateIdentifier;
    value?: Expression | null | undefined;
    computed: boolean;
    static: boolean;
}

export interface FunctionExpression extends BaseFunction, BaseExpression {
    id?: Identifier | null | undefined;
<<<<<<< Updated upstream
    type: "FunctionExpression";
=======
    type: 'FunctionExpression';
>>>>>>> Stashed changes
    body: BlockStatement;
}

export interface SequenceExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "SequenceExpression";
=======
    type: 'SequenceExpression';
>>>>>>> Stashed changes
    expressions: Expression[];
}

export interface UnaryExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "UnaryExpression";
=======
    type: 'UnaryExpression';
>>>>>>> Stashed changes
    operator: UnaryOperator;
    prefix: true;
    argument: Expression;
}

export interface BinaryExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "BinaryExpression";
=======
    type: 'BinaryExpression';
>>>>>>> Stashed changes
    operator: BinaryOperator;
    left: Expression;
    right: Expression;
}

export interface AssignmentExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "AssignmentExpression";
=======
    type: 'AssignmentExpression';
>>>>>>> Stashed changes
    operator: AssignmentOperator;
    left: Pattern | MemberExpression;
    right: Expression;
}

export interface UpdateExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "UpdateExpression";
=======
    type: 'UpdateExpression';
>>>>>>> Stashed changes
    operator: UpdateOperator;
    argument: Expression;
    prefix: boolean;
}

export interface LogicalExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "LogicalExpression";
=======
    type: 'LogicalExpression';
>>>>>>> Stashed changes
    operator: LogicalOperator;
    left: Expression;
    right: Expression;
}

export interface ConditionalExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "ConditionalExpression";
=======
    type: 'ConditionalExpression';
>>>>>>> Stashed changes
    test: Expression;
    alternate: Expression;
    consequent: Expression;
}

export interface BaseCallExpression extends BaseExpression {
    callee: Expression | Super;
    arguments: Array<Expression | SpreadElement>;
}
export type CallExpression = SimpleCallExpression | NewExpression;

export interface SimpleCallExpression extends BaseCallExpression {
<<<<<<< Updated upstream
    type: "CallExpression";
=======
    type: 'CallExpression';
>>>>>>> Stashed changes
    optional: boolean;
}

export interface NewExpression extends BaseCallExpression {
<<<<<<< Updated upstream
    type: "NewExpression";
}

export interface MemberExpression extends BaseExpression, BasePattern {
    type: "MemberExpression";
=======
    type: 'NewExpression';
}

export interface MemberExpression extends BaseExpression, BasePattern {
    type: 'MemberExpression';
>>>>>>> Stashed changes
    object: Expression | Super;
    property: Expression | PrivateIdentifier;
    computed: boolean;
    optional: boolean;
}

export type Pattern = Identifier | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | MemberExpression;

export interface BasePattern extends BaseNode {}

export interface SwitchCase extends BaseNode {
<<<<<<< Updated upstream
    type: "SwitchCase";
=======
    type: 'SwitchCase';
>>>>>>> Stashed changes
    test?: Expression | null | undefined;
    consequent: Statement[];
}

export interface CatchClause extends BaseNode {
<<<<<<< Updated upstream
    type: "CatchClause";
=======
    type: 'CatchClause';
>>>>>>> Stashed changes
    param: Pattern | null;
    body: BlockStatement;
}

export interface Identifier extends BaseNode, BaseExpression, BasePattern {
<<<<<<< Updated upstream
    type: "Identifier";
=======
    type: 'Identifier';
>>>>>>> Stashed changes
    name: string;
}

export type Literal = SimpleLiteral | RegExpLiteral | BigIntLiteral;

export interface SimpleLiteral extends BaseNode, BaseExpression {
<<<<<<< Updated upstream
    type: "Literal";
=======
    type: 'Literal';
>>>>>>> Stashed changes
    value: string | boolean | number | null;
    raw?: string | undefined;
}

export interface RegExpLiteral extends BaseNode, BaseExpression {
<<<<<<< Updated upstream
    type: "Literal";
=======
    type: 'Literal';
>>>>>>> Stashed changes
    value?: RegExp | null | undefined;
    regex: {
        pattern: string;
        flags: string;
    };
    raw?: string | undefined;
}

export interface BigIntLiteral extends BaseNode, BaseExpression {
<<<<<<< Updated upstream
    type: "Literal";
=======
    type: 'Literal';
>>>>>>> Stashed changes
    value?: bigint | null | undefined;
    bigint: string;
    raw?: string | undefined;
}

<<<<<<< Updated upstream
export type UnaryOperator = "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";

export type BinaryOperator =
    | "=="
    | "!="
    | "==="
    | "!=="
    | "<"
    | "<="
    | ">"
    | ">="
    | "<<"
    | ">>"
    | ">>>"
    | "+"
    | "-"
    | "*"
    | "/"
    | "%"
    | "**"
    | "|"
    | "^"
    | "&"
    | "in"
    | "instanceof";

export type LogicalOperator = "||" | "&&" | "??";

export type AssignmentOperator =
    | "="
    | "+="
    | "-="
    | "*="
    | "/="
    | "%="
    | "**="
    | "<<="
    | ">>="
    | ">>>="
    | "|="
    | "^="
    | "&="
    | "||="
    | "&&="
    | "??=";

export type UpdateOperator = "++" | "--";

export interface ForOfStatement extends BaseForXStatement {
    type: "ForOfStatement";
=======
export type UnaryOperator = '-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete';

export type BinaryOperator =
    | '=='
    | '!='
    | '==='
    | '!=='
    | '<'
    | '<='
    | '>'
    | '>='
    | '<<'
    | '>>'
    | '>>>'
    | '+'
    | '-'
    | '*'
    | '/'
    | '%'
    | '**'
    | '|'
    | '^'
    | '&'
    | 'in'
    | 'instanceof';

export type LogicalOperator = '||' | '&&' | '??';

export type AssignmentOperator =
    | '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '**='
    | '<<='
    | '>>='
    | '>>>='
    | '|='
    | '^='
    | '&='
    | '||='
    | '&&='
    | '??=';

export type UpdateOperator = '++' | '--';

export interface ForOfStatement extends BaseForXStatement {
    type: 'ForOfStatement';
>>>>>>> Stashed changes
    await: boolean;
}

export interface Super extends BaseNode {
<<<<<<< Updated upstream
    type: "Super";
}

export interface SpreadElement extends BaseNode {
    type: "SpreadElement";
=======
    type: 'Super';
}

export interface SpreadElement extends BaseNode {
    type: 'SpreadElement';
>>>>>>> Stashed changes
    argument: Expression;
}

export interface ArrowFunctionExpression extends BaseExpression, BaseFunction {
<<<<<<< Updated upstream
    type: "ArrowFunctionExpression";
=======
    type: 'ArrowFunctionExpression';
>>>>>>> Stashed changes
    expression: boolean;
    body: BlockStatement | Expression;
}

export interface YieldExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "YieldExpression";
=======
    type: 'YieldExpression';
>>>>>>> Stashed changes
    argument?: Expression | null | undefined;
    delegate: boolean;
}

export interface TemplateLiteral extends BaseExpression {
<<<<<<< Updated upstream
    type: "TemplateLiteral";
=======
    type: 'TemplateLiteral';
>>>>>>> Stashed changes
    quasis: TemplateElement[];
    expressions: Expression[];
}

export interface TaggedTemplateExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "TaggedTemplateExpression";
=======
    type: 'TaggedTemplateExpression';
>>>>>>> Stashed changes
    tag: Expression;
    quasi: TemplateLiteral;
}

export interface TemplateElement extends BaseNode {
<<<<<<< Updated upstream
    type: "TemplateElement";
=======
    type: 'TemplateElement';
>>>>>>> Stashed changes
    tail: boolean;
    value: {
        /** It is null when the template literal is tagged and the text has an invalid escape (e.g. - tag`\unicode and \u{55}`) */
        cooked?: string | null | undefined;
        raw: string;
    };
}

export interface AssignmentProperty extends Property {
    value: Pattern;
<<<<<<< Updated upstream
    kind: "init";
=======
    kind: 'init';
>>>>>>> Stashed changes
    method: boolean; // false
}

export interface ObjectPattern extends BasePattern {
<<<<<<< Updated upstream
    type: "ObjectPattern";
=======
    type: 'ObjectPattern';
>>>>>>> Stashed changes
    properties: Array<AssignmentProperty | RestElement>;
}

export interface ArrayPattern extends BasePattern {
<<<<<<< Updated upstream
    type: "ArrayPattern";
=======
    type: 'ArrayPattern';
>>>>>>> Stashed changes
    elements: Array<Pattern | null>;
}

export interface RestElement extends BasePattern {
<<<<<<< Updated upstream
    type: "RestElement";
=======
    type: 'RestElement';
>>>>>>> Stashed changes
    argument: Pattern;
}

export interface AssignmentPattern extends BasePattern {
<<<<<<< Updated upstream
    type: "AssignmentPattern";
=======
    type: 'AssignmentPattern';
>>>>>>> Stashed changes
    left: Pattern;
    right: Expression;
}

export type Class = ClassDeclaration | ClassExpression;
export interface BaseClass extends BaseNode {
    superClass?: Expression | null | undefined;
    body: ClassBody;
}

export interface ClassBody extends BaseNode {
<<<<<<< Updated upstream
    type: "ClassBody";
=======
    type: 'ClassBody';
>>>>>>> Stashed changes
    body: Array<MethodDefinition | PropertyDefinition | StaticBlock>;
}

export interface MethodDefinition extends BaseNode {
<<<<<<< Updated upstream
    type: "MethodDefinition";
    key: Expression | PrivateIdentifier;
    value: FunctionExpression;
    kind: "constructor" | "method" | "get" | "set";
=======
    type: 'MethodDefinition';
    key: Expression | PrivateIdentifier;
    value: FunctionExpression;
    kind: 'constructor' | 'method' | 'get' | 'set';
>>>>>>> Stashed changes
    computed: boolean;
    static: boolean;
}

export interface ClassDeclaration extends BaseClass, BaseDeclaration {
<<<<<<< Updated upstream
    type: "ClassDeclaration";
=======
    type: 'ClassDeclaration';
>>>>>>> Stashed changes
    /** It is null when a class declaration is a part of the `export default class` statement */
    id: Identifier | null;
}

export interface ClassExpression extends BaseClass, BaseExpression {
<<<<<<< Updated upstream
    type: "ClassExpression";
=======
    type: 'ClassExpression';
>>>>>>> Stashed changes
    id?: Identifier | null | undefined;
}

export interface MetaProperty extends BaseExpression {
<<<<<<< Updated upstream
    type: "MetaProperty";
=======
    type: 'MetaProperty';
>>>>>>> Stashed changes
    meta: Identifier;
    property: Identifier;
}

export type ModuleDeclaration =
    | ImportDeclaration
    | ExportNamedDeclaration
    | ExportDefaultDeclaration
    | ExportAllDeclaration;
export interface BaseModuleDeclaration extends BaseNode {}

export type ModuleSpecifier = ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier;
export interface BaseModuleSpecifier extends BaseNode {
    local: Identifier;
}

export interface ImportDeclaration extends BaseModuleDeclaration {
<<<<<<< Updated upstream
    type: "ImportDeclaration";
=======
    type: 'ImportDeclaration';
>>>>>>> Stashed changes
    specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>;
    source: Literal;
}

export interface ImportSpecifier extends BaseModuleSpecifier {
<<<<<<< Updated upstream
    type: "ImportSpecifier";
=======
    type: 'ImportSpecifier';
>>>>>>> Stashed changes
    imported: Identifier;
}

export interface ImportExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "ImportExpression";
=======
    type: 'ImportExpression';
>>>>>>> Stashed changes
    source: Expression;
}

export interface ImportDefaultSpecifier extends BaseModuleSpecifier {
<<<<<<< Updated upstream
    type: "ImportDefaultSpecifier";
}

export interface ImportNamespaceSpecifier extends BaseModuleSpecifier {
    type: "ImportNamespaceSpecifier";
}

export interface ExportNamedDeclaration extends BaseModuleDeclaration {
    type: "ExportNamedDeclaration";
=======
    type: 'ImportDefaultSpecifier';
}

export interface ImportNamespaceSpecifier extends BaseModuleSpecifier {
    type: 'ImportNamespaceSpecifier';
}

export interface ExportNamedDeclaration extends BaseModuleDeclaration {
    type: 'ExportNamedDeclaration';
>>>>>>> Stashed changes
    declaration?: Declaration | null | undefined;
    specifiers: ExportSpecifier[];
    source?: Literal | null | undefined;
}

export interface ExportSpecifier extends BaseModuleSpecifier {
<<<<<<< Updated upstream
    type: "ExportSpecifier";
=======
    type: 'ExportSpecifier';
>>>>>>> Stashed changes
    exported: Identifier;
}

export interface ExportDefaultDeclaration extends BaseModuleDeclaration {
<<<<<<< Updated upstream
    type: "ExportDefaultDeclaration";
=======
    type: 'ExportDefaultDeclaration';
>>>>>>> Stashed changes
    declaration: Declaration | Expression;
}

export interface ExportAllDeclaration extends BaseModuleDeclaration {
<<<<<<< Updated upstream
    type: "ExportAllDeclaration";
=======
    type: 'ExportAllDeclaration';
>>>>>>> Stashed changes
    exported: Identifier | null;
    source: Literal;
}

export interface AwaitExpression extends BaseExpression {
<<<<<<< Updated upstream
    type: "AwaitExpression";
=======
    type: 'AwaitExpression';
>>>>>>> Stashed changes
    argument: Expression;
}
